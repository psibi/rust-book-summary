<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functional language features: Iterators and Closures - Rust Book Summary</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">3.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">4.</strong> Common Programming Concepts</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">5.</strong> Undersanding Ownership</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">6.</strong> Using Structs</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">7.</strong> Enums and Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">8.</strong> Managing Growing Projects with Packages, Crates and Modules</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">9.</strong> Common Collections</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">10.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">11.</strong> Generic Types, Traits and Lifetimes</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">12.</strong> Writing Automated Tests</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">13.</strong> Chapter 12</a></li><li class="chapter-item expanded "><a href="chapter_13.html" class="active"><strong aria-hidden="true">14.</strong> Functional language features: Iterators and Closures</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">15.</strong> More about Cargo and Crates.io</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">16.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">17.</strong> Fearless Concurrency</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">18.</strong> OOP Features of Rust</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">19.</strong> Patterns and matching</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">20.</strong> Advanced Features</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">21.</strong> Chapter 20</a></li><li class="chapter-item expanded "><a href="miscellaneous.html"><strong aria-hidden="true">22.</strong> Miscellaneous</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Book Summary</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-13---functional-language-features-iterators-and-closures"><a class="header" href="#chapter-13---functional-language-features-iterators-and-closures">Chapter 13 - Functional Language Features: Iterators and Closures</a></h1>
<h2 id="motivation-for-closure"><a class="header" href="#motivation-for-closure">Motivation for Closure</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Cons: In the above function, you call <code>simulated_expensive_calculation</code>
twice in the first if block. Let's improve it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In the above implementation, the expensive computation is computed
only once. Unfortantely for cases where <code>intensity &gt;= 25 &amp;&amp; random_number == 3</code>, we have to perform the expensive computation
although it isn't required. Let's use closures here.</p>
<p>To define a closure, we start with a pair of vertical pipes (<code>|</code>),
inside which we specify the parameters to the closure:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However the above implementation has the same problem of the first
variant. We could fix this problem by creating a variable local to
that if block to hold the result of calling the closure, but closures
provide us with another solution. Let's learn something more before
finding out solution to the above problem.</p>
<h2 id="closure-type-inference-and-annotation"><a class="header" href="#closure-type-inference-and-annotation">Closure Type Inference and Annotation</a></h2>
<p>Closures don’t require you to annotate the types of the parameters or
the return value like <code>fn</code> functions do. But we can add type
annotations if we want to increase explicitness and clarity at the
cost of being more verbose than is strictly necessary.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expensive_closure = |num: u32| -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
<span class="boring">}
</span></code></pre></pre>
<p>Closure definitions will have one concrete type inferred for each of
their parameters and for their return value. The following code won't
compile:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
<span class="boring">}
</span></code></pre></pre>
<h2 id="storing-closures-using-generic-parameters-and-the-fn-traits"><a class="header" href="#storing-closures-using-generic-parameters-and-the-fn-traits">Storing Closures Using Generic Parameters and the <code>Fn</code> Traits</a></h2>
<p>One solution to the above function <code>generate_workout</code> is to save the
result of the expensive closure in a variable for reuse and use the
variable in each place we need the result.</p>
<p>To make a struct that holds a closure, we need to specify the type of
the closure, because a struct definition needs to know the types of
each of its fields. Each closure instance has its own unique anonymous
type: that is, even if two closures have the same signature, their
types are still considered different.</p>
<p>The <code>Fn</code> traits are provided by the standard library. All closures
implement at least one of the traits: <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Cacher</code> struct has a <code>calculation</code> field of the generic type <code>T</code>. The
trait bounds on T specify that it’s a closure by using the Fn
trait. Any closure we want to store in the <code>calculation</code> field must have
one <code>u32</code> parameter (specified within the parentheses after <code>Fn</code>) and must
return a <code>u32</code> (specified after the <code>-&gt;</code>).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And now the implementation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The above implementation doesn't suffer from any of the above cons
discussed above. The function is computed only once when required.</p>
<p>But there is a problem with the above implementation. The code will
fail (obviously) for this scenario:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
<span class="boring">}
</span></code></pre></pre>
<p>This problem can be fixed by changing the struct implementation to
store the key and value mapping in a hashmap.</p>
<h2 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">Capturing the Environment with Closures</a></h2>
<p>In the above example, we used closures as inline anonymous
functions. We can also use it to capture their environment and access
variables from the scope in which they're defined.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>whereas something like this will result in an compile error:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>Closures can capture values from their environment in three ways,
which directly map to the three ways a function can take a parameter:
taking ownership, borrowing mutably, and borrowing immutably. These
are encoded in the three <code>Fn</code> traits as follows:</p>
<ul>
<li><code>FnOnce</code> consumes the variables it captures from its enclosing scope,
known as the closure’s environment. To consume the captured
variables, the closure must take ownership of these variables and
move them into the closure when it is defined. The <code>Once</code> part of the
name represents the fact that the closure can’t take ownership of
the same variables more than once, so it can be called only once.</li>
<li><code>FnMut</code> can change the environment because it mutably borrows values.</li>
<li><code>Fn</code> borrows values from the environment immutably.</li>
</ul>
<p>When you create a closure, Rust infers which trait to use based on how
the closure uses the values from the environment. All closures
implement <code>FnOnce</code> because they can all be called <code>at least</code>
once. Closures that don’t move the captured variables also implement
<code>FnMut</code>, and closures that don’t need mutable access to the captured
variables also implement <code>Fn</code>.</p>
<p><a href="https://www.reddit.com/r/rust/comments/2s7l0m/whats_the_usecase_for_fnonce/">Reddit thread on usecase of FnOnce</a></p>
<p>If you want to force the closure to take ownership of the values it
uses in the environment, you can use the <code>move</code> keyword before the
parameter list. This technique is mostly useful when passing a closure
to a new thread to move the data so it’s owned by the new
thread. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>The above program will result in compile error till you have the
printlin statement in the code.</p>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<ul>
<li><a href="https://stackoverflow.com/a/32310313/1651941">Understand this answer - self, Self</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator crate link</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/index.html">std::iter documentation</a></li>
</ul>
<p>Three forms of iteration:</p>
<ul>
<li><code>iter()</code> iterates over <code>&amp;T</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
    println!(&quot;{:?}&quot;, v1);
    for v in v1_iter {
        println!(&quot;Got {}&quot;, v);
    }
    println!(&quot;{:?}&quot;, v1);
}
</code></pre></pre>
<ul>
<li><code>iter_mut</code> iterates over <code>&amp;mut T</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v1 = vec![1, 2, 3];

    let v1_iter: std::slice::IterMut&lt;u8&gt; = v1.iter_mut();
    for v in v1_iter {
        *v = *v + 2;
        println!(&quot;Got {}&quot;, v);
    }
    // println!(&quot;{:?}&quot;, v1); Uncommenting this results in compile error
}
</code></pre></pre>
<p>The above results in a compile error because mutable references have
one big restriction: you can have only one mutable reference to a
particular piece of data in a particular scope. And in the above code,
<code>v1</code>'s mutable borrow has already happened and <code>v1_iter</code> has mutable
reference to that in the scope. When you try to print it, you try to
immutably borrow - but the mixing isn't permitted. So, you can
overcome that like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v1 = vec![1, 2, 3];

    {
        let v1_iter: std::slice::IterMut&lt;u8&gt; = v1.iter_mut();
        for v in v1_iter {
            *v = *v + 2;
            println!(&quot;Got {}&quot;, v);
        }
    }
    println!(&quot;{:?}&quot;, v1);
}
</code></pre></pre>
<p>Note that even this will work as after the for loop ends, the scope of the borrow ends:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v1 = vec![1, 2, 3];

    for v in v1.iter_mut() {
        *v = *v + 2;
        println!(&quot;Got {}&quot;, v);
    }
    println!(&quot;{:?}&quot;, v1);
}
</code></pre></pre>
<ul>
<li><code>into_iter()</code> iterates over <code>T</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter: std::vec::IntoIter&lt;u8&gt; = v1.into_iter();
    for v in v1_iter {
        println!(&quot;Got {}&quot;, v);
    }
    // println!(&quot;{:?}&quot;, v1); Uncommenting this results in compile error
}
</code></pre></pre>
<p>Note that if you restructure it like this, it still won't compile (the reason being <code>v1</code> is borrowed):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v1 = vec![1, 2, 3];
    {
        let v1_iter: std::vec::IntoIter&lt;u8&gt; = v1.into_iter();
        for v in v1_iter {
            println!(&quot;Got {}&quot;, v);
        }
    }
    println!(&quot;{:?}&quot;, v1);
}
</code></pre></pre>
<h2 id="other-examples"><a class="header" href="#other-examples">Other Examples</a></h2>
<ul>
<li><code>collect</code> function transforms an iterator into a collection.</li>
<li><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.map">map function</a></li>
<li><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.filter">filter function</a></li>
<li><a href="https://stackoverflow.com/q/57321971/1651941">SO question</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v1: [i32; 3] = [1, 2, 3];
    let v2: Vec&lt;i32&gt; = v1.iter().map(|x| x * 2).collect();
    let v3: Vec&lt;&amp;i32&gt; = v1.iter().filter(|x| **x == 1).collect();
    println!(&quot;{:?}&quot;, v1);
    println!(&quot;{:?}&quot;, v2);
    println!(&quot;{:?}&quot;, v3);
}
</code></pre></pre>
<p>Why does v3 is annotated with <code>Vec&lt;&amp;i32&gt;</code> and not <code>Vec&lt;i32&gt;</code> and why
does it has <code>**</code> ?</p>
<p>In <code>v3</code>, we do <code>vi.iter()</code> which passes <code>&amp;i32</code> into filter. But the
type of predicate in filter is <code>FnMut(&amp;Self::Item) -&gt; Bool</code>. So the
type of x becomes <code>&amp;&amp;i32</code>. So, you do two de-references to get the
value. That answers the second part of the question. The type is
<code>Vec&lt;i32&gt;</code> as the type of predicate for map is <code>FnMut(Self::Item) -&gt; B</code> whereas for filter it is <code>FnMut(&amp;Self::Item -&gt; Bool)</code>. And hence
the different type signature.</p>
<p>Different map variants:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v1: Vec&lt;i32&gt; = vec![1, 2, 3];
    let v2: Vec&lt;i32&gt; = v1.iter().map(|x| x * 2).collect();
    let v3: Vec&lt;i32&gt; = v1.iter_mut().map(|x| *x * 2).collect();
    let v4: Vec&lt;()&gt; = v1.iter_mut().map(|x| *x = *x * 2).collect();
    let v5: Vec&lt;&amp;mut i32&gt; = v1
        .iter_mut()
        .map(|x| {
            *x = *x * 2;
            x
        }).collect();

    // println!(&quot;{:?}&quot;, v1); Uncommenting this will result in an compile error
    println!(&quot;{:?}&quot;, v2);
    println!(&quot;{:?}&quot;, v3);
    println!(&quot;{:?}&quot;, v4);
    println!(&quot;{:?}&quot;, v5);
}
</code></pre></pre>
<p>Note that <code>v4</code> style is not recommened. Uncommenting the line will
result in compile error because <code>v5</code> has a mutuable borrow on <code>v1</code>.</p>
<p>Different filter variations:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];
let v2: Vec&lt;i32&gt; = v1.into_iter().filter(|x| *x == 2).collect();
println!(&quot;{:?}&quot;, v2);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];
let v2: Vec&lt;&amp;i32&gt; = v1.iter().filter(|&amp;x| *x == 2).collect();
println!(&quot;{:?}&quot;, v2);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v1: Vec&lt;i32&gt; = vec![1, 2, 3];
let v2: Vec&lt;&amp;mut i32&gt; = v1.iter_mut().filter(|x| **x == 2).collect();
println!(&quot;{:?}&quot;, v2);
<span class="boring">}
</span></code></pre></pre>
<p>Note that there are two styles of coding: iterator and loops. Most
rust programmers prefer iterator style. Also, there is no much
performance difference between both of them.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_12.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter_14.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_12.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter_14.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
